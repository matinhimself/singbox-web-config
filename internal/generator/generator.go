package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// GenerationMetadata tracks information about the generation process
type GenerationMetadata struct {
	Timestamp        time.Time
	SingBoxCommit    string
	SingBoxBranch    string
	GeneratorVersion string
	FilesProcessed   int
	TypesGenerated   int
}

// CodeGenerator generates Go source code from extracted types
type CodeGenerator struct {
	OutputDir string
	Metadata  *GenerationMetadata
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(outputDir string) *CodeGenerator {
	return &CodeGenerator{
		OutputDir: outputDir,
		Metadata: &GenerationMetadata{
			Timestamp:        time.Now(),
			GeneratorVersion: "0.1.0",
		},
	}
}

// Generate generates Go source files from rule types
func (g *CodeGenerator) Generate(types []*RuleType) error {
	// Create output directory
	if err := os.MkdirAll(g.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	fmt.Printf("Generating types in %s...\n", g.OutputDir)

	// Generate types file
	if err := g.generateTypesFile(types); err != nil {
		return fmt.Errorf("failed to generate types file: %w", err)
	}

	// Generate metadata file
	g.Metadata.TypesGenerated = len(types)
	if err := g.GenerateMetadata(); err != nil {
		return fmt.Errorf("failed to generate metadata: %w", err)
	}

	fmt.Printf("Successfully generated %d types\n", len(types))
	return nil
}

// GenerateToFile generates types to a specific file
func (g *CodeGenerator) GenerateToFile(types []*RuleType, filename string) error {
	// Create output directory
	if err := os.MkdirAll(g.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	fmt.Printf("Generating %d types to %s...\n", len(types), filename)

	tmpl := template.Must(template.New("types").Funcs(template.FuncMap{
		"typeNameToUI": typeNameToUI,
	}).Parse(typesTemplate))

	var buf bytes.Buffer
	data := map[string]interface{}{
		"Timestamp": g.Metadata.Timestamp.Format(time.RFC3339),
		"Commit":    g.Metadata.SingBoxCommit,
		"Branch":    g.Metadata.SingBoxBranch,
		"Types":     types,
	}

	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, save unformatted code for debugging
		fmt.Printf("Warning: failed to format code: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file
	outputPath := filepath.Join(g.OutputDir, filename)
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// generateTypesFile generates a single file with all types
func (g *CodeGenerator) generateTypesFile(types []*RuleType) error {
	tmpl := template.Must(template.New("types").Funcs(template.FuncMap{
		"typeNameToUI": typeNameToUI,
	}).Parse(typesTemplate))

	var buf bytes.Buffer
	data := map[string]interface{}{
		"Timestamp": g.Metadata.Timestamp.Format(time.RFC3339),
		"Commit":    g.Metadata.SingBoxCommit,
		"Branch":    g.Metadata.SingBoxBranch,
		"Types":     types,
	}

	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, save unformatted code for debugging
		fmt.Printf("Warning: failed to format code: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file
	outputPath := filepath.Join(g.OutputDir, "rules.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// GenerateMetadata generates a metadata file
func (g *CodeGenerator) GenerateMetadata() error {
	tmpl := template.Must(template.New("metadata").Parse(metadataTemplate))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, g.Metadata); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	outputPath := filepath.Join(g.OutputDir, "metadata.go")
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write metadata: %w", err)
	}

	return nil
}

// typeNameToUI converts a type name to a UI-friendly name
func typeNameToUI(name string) string {
	// Remove "Rule" suffix
	name = strings.TrimSuffix(name, "Rule")
	name = strings.TrimSuffix(name, "Item")

	// Add spaces before capitals
	var result []rune
	for i, r := range name {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, ' ')
		}
		result = append(result, r)
	}

	return string(result)
}

const typesTemplate = `// Code generated by singbox-web-config generator. DO NOT EDIT.
// Source: https://github.com/SagerNet/sing-box/tree/{{.Branch}}/route/rule
// Commit: {{.Commit}}
// Generated at: {{.Timestamp}}

package types

{{range .Types}}
{{if .Doc}}// {{.Doc}}{{end}}
type {{.Name}} struct {
{{- range .Fields}}
	{{if .Doc}}// {{.Doc}}
	{{end}}{{.Name}} {{.Type}} ` + "`json:\"{{.JSONTag}}{{if not .Required}},omitempty{{end}}\"`" + `
{{- end}}
}
{{end}}
`

const metadataTemplate = `// Code generated by singbox-web-config generator. DO NOT EDIT.

package types

import "time"

// Metadata contains information about the code generation
var Metadata = struct {
	Timestamp        time.Time
	SingBoxCommit    string
	SingBoxBranch    string
	GeneratorVersion string
	TypesGenerated   int
}{
	Timestamp:        time.Unix({{.Timestamp.Unix}}, 0),
	SingBoxCommit:    "{{.SingBoxCommit}}",
	SingBoxBranch:    "{{.SingBoxBranch}}",
	GeneratorVersion: "{{.GeneratorVersion}}",
	TypesGenerated:   {{.TypesGenerated}},
}
`
